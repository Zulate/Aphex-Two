{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/OutlineNode.js"],
  "sourcesContent": ["import { DepthTexture, FloatType, RenderTarget, Vector2, TempNode, QuadMesh, NodeMaterial, RendererUtils, NodeUpdateType } from 'three/webgpu';\r\nimport { Loop, int, exp, min, float, mul, uv, vec2, vec3, Fn, textureSize, orthographicDepthToViewZ, screenUV, nodeObject, uniform, vec4, passTexture, texture, perspectiveDepthToViewZ, positionView, reference } from 'three/tsl';\r\n\r\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\r\nconst _size = /*@__PURE__*/ new Vector2();\r\nconst _BLUR_DIRECTION_X = /*@__PURE__*/ new Vector2( 1.0, 0.0 );\r\nconst _BLUR_DIRECTION_Y = /*@__PURE__*/ new Vector2( 0.0, 1.0 );\r\n\r\nlet _rendererState;\r\n\r\n/**\r\n * Post processing node for rendering outlines around selected objects. The node\r\n * gives you great flexibility in composing the final outline look depending on\r\n * your requirements.\r\n * ```js\r\n * const postProcessing = new THREE.PostProcessing( renderer );\r\n *\r\n * const scenePass = pass( scene, camera );\r\n *\r\n * // outline parameter\r\n *\r\n * const edgeStrength = uniform( 3.0 );\r\n * const edgeGlow = uniform( 0.0 );\r\n * const edgeThickness = uniform( 1.0 );\r\n * const visibleEdgeColor = uniform( new THREE.Color( 0xffffff ) );\r\n * const hiddenEdgeColor = uniform( new THREE.Color( 0x4e3636 ) );\r\n *\r\n * outlinePass = outline( scene, camera, {\r\n * \tselectedObjects,\r\n * \tedgeGlow,\r\n * \tedgeThickness\r\n * } );\r\n *\r\n * // compose custom outline\r\n *\r\n * const { visibleEdge, hiddenEdge } = outlinePass;\r\n * const outlineColor = visibleEdge.mul( visibleEdgeColor ).add( hiddenEdge.mul( hiddenEdgeColor ) ).mul( edgeStrength );\r\n *\r\n * postProcessing.outputNode = outlineColor.add( scenePass );\r\n * ```\r\n *\r\n * @augments TempNode\r\n * @three_import import { outline } from 'three/addons/tsl/display/OutlineNode.js';\r\n */\r\nclass OutlineNode extends TempNode {\r\n\r\n\tstatic get type() {\r\n\r\n\t\treturn 'OutlineNode';\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Constructs a new outline node.\r\n\t *\r\n\t * @param {Scene} scene - A reference to the scene.\r\n\t * @param {Camera} camera - The camera the scene is rendered with.\r\n\t * @param {Object} params - The configuration parameters.\r\n\t * @param {Array<Object3D>} params.selectedObjects - An array of selected objects.\r\n\t * @param {Node<float>} [params.edgeThickness=float(1)] - The thickness of the edges.\r\n\t * @param {Node<float>} [params.edgeGlow=float(0)] - Can be used for an animated glow/pulse effects.\r\n\t * @param {number} [params.downSampleRatio=2] - The downsample ratio.\r\n\t */\r\n\tconstructor( scene, camera, params = {} ) {\r\n\r\n\t\tsuper( 'vec4' );\r\n\r\n\t\tconst {\r\n\t\t\tselectedObjects = [],\r\n\t\t\tedgeThickness = float( 1 ),\r\n\t\t\tedgeGlow = float( 0 ),\r\n\t\t\tdownSampleRatio = 2\r\n\t\t} = params;\r\n\r\n\t\t/**\r\n\t\t * A reference to the scene.\r\n\t\t *\r\n\t\t * @type {Scene}\r\n\t\t */\r\n\t\tthis.scene = scene;\r\n\r\n\t\t/**\r\n\t\t * The camera the scene is rendered with.\r\n\t\t *\r\n\t\t * @type {Camera}\r\n\t\t */\r\n\t\tthis.camera = camera;\r\n\r\n\t\t/**\r\n\t\t * An array of selected objects.\r\n\t\t *\r\n\t\t * @type {Array<Object3D>}\r\n\t\t */\r\n\t\tthis.selectedObjects = selectedObjects;\r\n\r\n\t\t/**\r\n\t\t * The thickness of the edges.\r\n\t\t *\r\n\t\t * @type {Node<float>}\r\n\t\t */\r\n\t\tthis.edgeThicknessNode = nodeObject( edgeThickness );\r\n\r\n\t\t/**\r\n\t\t * Can be used for an animated glow/pulse effect.\r\n\t\t *\r\n\t\t * @type {Node<float>}\r\n\t\t */\r\n\t\tthis.edgeGlowNode = nodeObject( edgeGlow );\r\n\r\n\t\t/**\r\n\t\t * The downsample ratio.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 2\r\n\t\t */\r\n\t\tthis.downSampleRatio = downSampleRatio;\r\n\r\n\t\t/**\r\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\r\n\t\t * its effect once per frame in `updateBefore()`.\r\n\t\t *\r\n\t\t * @type {string}\r\n\t\t * @default 'frame'\r\n\t\t */\r\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\r\n\r\n\t\t// render targets\r\n\r\n\t\t/**\r\n\t\t * The render target for the depth pre-pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {RenderTarget}\r\n\t\t */\r\n\t\tthis._renderTargetDepthBuffer = new RenderTarget();\r\n\t\tthis._renderTargetDepthBuffer.depthTexture = new DepthTexture();\r\n\t\tthis._renderTargetDepthBuffer.depthTexture.type = FloatType;\r\n\r\n\t\t/**\r\n\t\t * The render target for the mask pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {RenderTarget}\r\n\t\t */\r\n\t\tthis._renderTargetMaskBuffer = new RenderTarget();\r\n\r\n\t\t/**\r\n\t\t * The render target for the mask downsample.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {RenderTarget}\r\n\t\t */\r\n\t\tthis._renderTargetMaskDownSampleBuffer = new RenderTarget( 1, 1, { depthBuffer: false } );\r\n\r\n\t\t/**\r\n\t\t * The first render target for the edge detection.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {RenderTarget}\r\n\t\t */\r\n\t\tthis._renderTargetEdgeBuffer1 = new RenderTarget( 1, 1, { depthBuffer: false } );\r\n\r\n\t\t/**\r\n\t\t * The second render target for the edge detection.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {RenderTarget}\r\n\t\t */\r\n\t\tthis._renderTargetEdgeBuffer2 = new RenderTarget( 1, 1, { depthBuffer: false } );\r\n\r\n\t\t/**\r\n\t\t * The first render target for the blur pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {RenderTarget}\r\n\t\t */\r\n\t\tthis._renderTargetBlurBuffer1 = new RenderTarget( 1, 1, { depthBuffer: false } );\r\n\r\n\t\t/**\r\n\t\t * The second render target for the blur pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {RenderTarget}\r\n\t\t */\r\n\t\tthis._renderTargetBlurBuffer2 = new RenderTarget( 1, 1, { depthBuffer: false } );\r\n\r\n\t\t/**\r\n\t\t * The render target for the final composite.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {RenderTarget}\r\n\t\t */\r\n\t\tthis._renderTargetComposite = new RenderTarget( 1, 1, { depthBuffer: false } );\r\n\r\n\t\t// uniforms\r\n\r\n\t\t/**\r\n\t\t * Represents the near value of the scene's camera.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {ReferenceNode<float>}\r\n\t\t */\r\n\t\tthis._cameraNear = reference( 'near', 'float', camera );\r\n\r\n\t\t/**\r\n\t\t * Represents the far value of the scene's camera.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {ReferenceNode<float>}\r\n\t\t */\r\n\t\tthis._cameraFar = reference( 'far', 'float', camera );\r\n\r\n\t\t/**\r\n\t\t * Uniform that represents the blur direction of the pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {UniformNode<vec2>}\r\n\t\t */\r\n\t\tthis._blurDirection = uniform( new Vector2() );\r\n\r\n\t\t/**\r\n\t\t * Texture node that holds the data from the depth pre-pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {TextureNode}\r\n\t\t */\r\n\t\tthis._depthTextureUniform = texture( this._renderTargetDepthBuffer.depthTexture );\r\n\r\n\t\t/**\r\n\t\t * Texture node that holds the data from the mask pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {TextureNode}\r\n\t\t */\r\n\t\tthis._maskTextureUniform = texture( this._renderTargetMaskBuffer.texture );\r\n\r\n\t\t/**\r\n\t\t * Texture node that holds the data from the mask downsample pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {TextureNode}\r\n\t\t */\r\n\t\tthis._maskTextureDownsSampleUniform = texture( this._renderTargetMaskDownSampleBuffer.texture );\r\n\r\n\t\t/**\r\n\t\t * Texture node that holds the data from the first edge detection pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {TextureNode}\r\n\t\t */\r\n\t\tthis._edge1TextureUniform = texture( this._renderTargetEdgeBuffer1.texture );\r\n\r\n\t\t/**\r\n\t\t * Texture node that holds the data from the second edge detection pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {TextureNode}\r\n\t\t */\r\n\t\tthis._edge2TextureUniform = texture( this._renderTargetEdgeBuffer2.texture );\r\n\r\n\t\t/**\r\n\t\t * Texture node that holds the current blurred color data.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {TextureNode}\r\n\t\t */\r\n\t\tthis._blurColorTextureUniform = texture( this._renderTargetEdgeBuffer1.texture );\r\n\r\n\t\t// constants\r\n\r\n\t\t/**\r\n\t\t * Visible edge color.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {Node<vec3>}\r\n\t\t */\r\n\t\tthis._visibleEdgeColor = vec3( 1, 0, 0 );\r\n\r\n\t\t/**\r\n\t\t * Hidden edge color.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {Node<vec3>}\r\n\t\t */\r\n\t\tthis._hiddenEdgeColor = vec3( 0, 1, 0 );\r\n\r\n\t\t// materials\r\n\r\n\t\t/**\r\n\t\t * The material for the depth pre-pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {NodeMaterial}\r\n\t\t */\r\n\t\tthis._depthMaterial = new NodeMaterial();\r\n\t\tthis._depthMaterial.fragmentNode = vec4( 0, 0, 0, 1 );\r\n\t\tthis._depthMaterial.name = 'OutlineNode.depth';\r\n\r\n\t\t/**\r\n\t\t * The material for preparing the mask.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {NodeMaterial}\r\n\t\t */\r\n\t\tthis._prepareMaskMaterial = new NodeMaterial();\r\n\t\tthis._prepareMaskMaterial.name = 'OutlineNode.prepareMask';\r\n\r\n\t\t/**\r\n\t\t * The copy material\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {NodeMaterial}\r\n\t\t */\r\n\t\tthis._materialCopy = new NodeMaterial();\r\n\t\tthis._materialCopy.name = 'OutlineNode.copy';\r\n\r\n\t\t/**\r\n\t\t * The edge detection material.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {NodeMaterial}\r\n\t\t */\r\n\t\tthis._edgeDetectionMaterial = new NodeMaterial();\r\n\t\tthis._edgeDetectionMaterial.name = 'OutlineNode.edgeDetection';\r\n\r\n\t\t/**\r\n\t\t * The material that is used to render in the blur pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {NodeMaterial}\r\n\t\t */\r\n\t\tthis._separableBlurMaterial = new NodeMaterial();\r\n\t\tthis._separableBlurMaterial.name = 'OutlineNode.separableBlur';\r\n\r\n\t\t/**\r\n\t\t * The material that is used to render in the blur pass.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {NodeMaterial}\r\n\t\t */\r\n\t\tthis._separableBlurMaterial2 = new NodeMaterial();\r\n\t\tthis._separableBlurMaterial2.name = 'OutlineNode.separableBlur2';\r\n\r\n\t\t/**\r\n\t\t * The final composite material.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {NodeMaterial}\r\n\t\t */\r\n\t\tthis._compositeMaterial = new NodeMaterial();\r\n\t\tthis._compositeMaterial.name = 'OutlineNode.composite';\r\n\r\n\t\t/**\r\n\t\t * A set to cache selected objects in the scene.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {Set<Object3D>}\r\n\t\t */\r\n\t\tthis._selectionCache = new Set();\r\n\r\n\t\t/**\r\n\t\t * The result of the effect is represented as a separate texture node.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {PassTextureNode}\r\n\t\t */\r\n\t\tthis._textureNode = passTexture( this, this._renderTargetComposite.texture );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A mask value that represents the visible edge.\r\n\t *\r\n\t * @return {Node<float>} The visible edge.\r\n\t */\r\n\tget visibleEdge() {\r\n\r\n\t\treturn this.r;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A mask value that represents the hidden edge.\r\n\t *\r\n\t * @return {Node<float>} The hidden edge.\r\n\t */\r\n\tget hiddenEdge() {\r\n\r\n\t\treturn this.g;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the result of the effect as a texture node.\r\n\t *\r\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\r\n\t */\r\n\tgetTextureNode() {\r\n\r\n\t\treturn this._textureNode;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the size of the effect.\r\n\t *\r\n\t * @param {number} width - The width of the effect.\r\n\t * @param {number} height - The height of the effect.\r\n\t */\r\n\tsetSize( width, height ) {\r\n\r\n\t\tthis._renderTargetDepthBuffer.setSize( width, height );\r\n\t\tthis._renderTargetMaskBuffer.setSize( width, height );\r\n\t\tthis._renderTargetComposite.setSize( width, height );\r\n\r\n\t\t// downsample 1\r\n\r\n\t\tlet resx = Math.round( width / this.downSampleRatio );\r\n\t\tlet resy = Math.round( height / this.downSampleRatio );\r\n\r\n\t\tthis._renderTargetMaskDownSampleBuffer.setSize( resx, resy );\r\n\t\tthis._renderTargetEdgeBuffer1.setSize( resx, resy );\r\n\t\tthis._renderTargetBlurBuffer1.setSize( resx, resy );\r\n\r\n\t\t// downsample 2\r\n\r\n\t\tresx = Math.round( resx / 2 );\r\n\t\tresy = Math.round( resy / 2 );\r\n\r\n\t\tthis._renderTargetEdgeBuffer2.setSize( resx, resy );\r\n\t\tthis._renderTargetBlurBuffer2.setSize( resx, resy );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * This method is used to render the effect once per frame.\r\n\t *\r\n\t * @param {NodeFrame} frame - The current node frame.\r\n\t */\r\n\tupdateBefore( frame ) {\r\n\r\n\t\tconst { renderer } = frame;\r\n\t\tconst { camera, scene } = this;\r\n\r\n\t\t_rendererState = RendererUtils.resetRendererAndSceneState( renderer, scene, _rendererState );\r\n\r\n\t\t//\r\n\r\n\t\tconst size = renderer.getDrawingBufferSize( _size );\r\n\t\tthis.setSize( size.width, size.height );\r\n\r\n\t\t//\r\n\r\n\t\trenderer.setClearColor( 0xffffff, 1 );\r\n\r\n\t\tthis._updateSelectionCache();\r\n\r\n\t\t// 1. Draw non-selected objects in the depth buffer\r\n\r\n\t\tscene.overrideMaterial = this._depthMaterial;\r\n\r\n\t\trenderer.setRenderTarget( this._renderTargetDepthBuffer );\r\n\t\trenderer.setRenderObjectFunction( ( object, ...params ) => {\r\n\r\n\t\t\tif ( this._selectionCache.has( object ) === false ) {\r\n\r\n\t\t\t\trenderer.renderObject( object, ...params );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\trenderer.render( scene, camera );\r\n\r\n\t\t// 2. Draw only the selected objects by comparing the depth buffer of non-selected objects\r\n\r\n\t\tscene.overrideMaterial = this._prepareMaskMaterial;\r\n\r\n\t\trenderer.setRenderTarget( this._renderTargetMaskBuffer );\r\n\t\trenderer.setRenderObjectFunction( ( object, ...params ) => {\r\n\r\n\t\t\tif ( this._selectionCache.has( object ) === true ) {\r\n\r\n\t\t\t\trenderer.renderObject( object, ...params );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\trenderer.render( scene, camera );\r\n\r\n\t\t//\r\n\r\n\t\trenderer.setRenderObjectFunction( _rendererState.renderObjectFunction );\r\n\r\n\t\tthis._selectionCache.clear();\r\n\r\n\t\t// 3. Downsample to (at least) half resolution\r\n\r\n\t\t_quadMesh.material = this._materialCopy;\r\n\t\trenderer.setRenderTarget( this._renderTargetMaskDownSampleBuffer );\r\n\t\t_quadMesh.render( renderer );\r\n\r\n\t\t// 4. Perform edge detection (half resolution)\r\n\r\n\t\t_quadMesh.material = this._edgeDetectionMaterial;\r\n\t\trenderer.setRenderTarget( this._renderTargetEdgeBuffer1 );\r\n\t\t_quadMesh.render( renderer );\r\n\r\n\t\t// 5. Apply blur (half resolution)\r\n\r\n\t\tthis._blurColorTextureUniform.value = this._renderTargetEdgeBuffer1.texture;\r\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_X );\r\n\r\n\t\t_quadMesh.material = this._separableBlurMaterial;\r\n\t\trenderer.setRenderTarget( this._renderTargetBlurBuffer1 );\r\n\t\t_quadMesh.render( renderer );\r\n\r\n\t\tthis._blurColorTextureUniform.value = this._renderTargetBlurBuffer1.texture;\r\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_Y );\r\n\r\n\t\trenderer.setRenderTarget( this._renderTargetEdgeBuffer1 );\r\n\t\t_quadMesh.render( renderer );\r\n\r\n\t\t// 6. Apply blur (quarter resolution)\r\n\r\n\t\tthis._blurColorTextureUniform.value = this._renderTargetEdgeBuffer1.texture;\r\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_X );\r\n\r\n\t\t_quadMesh.material = this._separableBlurMaterial2;\r\n\t\trenderer.setRenderTarget( this._renderTargetBlurBuffer2 );\r\n\t\t_quadMesh.render( renderer );\r\n\r\n\t\tthis._blurColorTextureUniform.value = this._renderTargetBlurBuffer2.texture;\r\n\t\tthis._blurDirection.value.copy( _BLUR_DIRECTION_Y );\r\n\r\n\t\trenderer.setRenderTarget( this._renderTargetEdgeBuffer2 );\r\n\t\t_quadMesh.render( renderer );\r\n\r\n\t\t// 7. Composite\r\n\r\n\t\t_quadMesh.material = this._compositeMaterial;\r\n\t\trenderer.setRenderTarget( this._renderTargetComposite );\r\n\t\t_quadMesh.render( renderer );\r\n\r\n\t\t// restore\r\n\r\n\t\tRendererUtils.restoreRendererAndSceneState( renderer, scene, _rendererState );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * This method is used to setup the effect's TSL code.\r\n\t *\r\n\t * @param {NodeBuilder} builder - The current node builder.\r\n\t * @return {PassTextureNode}\r\n\t */\r\n\tsetup() {\r\n\r\n\t\t// prepare mask material\r\n\r\n\t\tconst prepareMask = () => {\r\n\r\n\t\t\tconst depth = this._depthTextureUniform.sample( screenUV );\r\n\r\n\t\t\tlet viewZNode;\r\n\r\n\t\t\tif ( this.camera.isPerspectiveCamera ) {\r\n\r\n\t\t\t\tviewZNode = perspectiveDepthToViewZ( depth, this._cameraNear, this._cameraFar );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tviewZNode = orthographicDepthToViewZ( depth, this._cameraNear, this._cameraFar );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst depthTest = positionView.z.lessThanEqual( viewZNode ).select( 1, 0 );\r\n\t\t\treturn vec4( 0.0, depthTest, 1.0, 1.0 );\r\n\r\n\t\t};\r\n\r\n\t\tthis._prepareMaskMaterial.fragmentNode = prepareMask();\r\n\t\tthis._prepareMaskMaterial.needsUpdate = true;\r\n\r\n\t\t// copy material\r\n\r\n\t\tthis._materialCopy.fragmentNode = this._maskTextureUniform;\r\n\t\tthis._materialCopy.needsUpdate = true;\r\n\r\n\t\t// edge detection material\r\n\r\n\t\tconst edgeDetection = Fn( () => {\r\n\r\n\t\t\tconst resolution = textureSize( this._maskTextureDownsSampleUniform );\r\n\t\t\tconst invSize = vec2( 1 ).div( resolution ).toVar();\r\n\t\t\tconst uvOffset = vec4( 1.0, 0.0, 0.0, 1.0 ).mul( vec4( invSize, invSize ) );\r\n\r\n\t\t\tconst uvNode = uv();\r\n\t\t\tconst c1 = this._maskTextureDownsSampleUniform.sample( uvNode.add( uvOffset.xy ) ).toVar();\r\n\t\t\tconst c2 = this._maskTextureDownsSampleUniform.sample( uvNode.sub( uvOffset.xy ) ).toVar();\r\n\t\t\tconst c3 = this._maskTextureDownsSampleUniform.sample( uvNode.add( uvOffset.yw ) ).toVar();\r\n\t\t\tconst c4 = this._maskTextureDownsSampleUniform.sample( uvNode.sub( uvOffset.yw ) ).toVar();\r\n\r\n\t\t\tconst diff1 = mul( c1.r.sub( c2.r ), 0.5 );\r\n\t\t\tconst diff2 = mul( c3.r.sub( c4.r ), 0.5 );\r\n\t\t\tconst d = vec2( diff1, diff2 ).length();\r\n\t\t\tconst a1 = min( c1.g, c2.g );\r\n\t\t\tconst a2 = min( c3.g, c4.g );\r\n\t\t\tconst visibilityFactor = min( a1, a2 );\r\n\t\t\tconst edgeColor = visibilityFactor.oneMinus().greaterThan( 0.001 ).select( this._visibleEdgeColor, this._hiddenEdgeColor );\r\n\t\t\treturn vec4( edgeColor, 1 ).mul( d );\r\n\r\n\t\t} );\r\n\r\n\t\tthis._edgeDetectionMaterial.fragmentNode = edgeDetection();\r\n\t\tthis._edgeDetectionMaterial.needsUpdate = true;\r\n\r\n\t\t// separable blur material\r\n\r\n\t\tconst MAX_RADIUS = 4;\r\n\r\n\t\tconst gaussianPdf = Fn( ( [ x, sigma ] ) => {\r\n\r\n\t\t\treturn float( 0.39894 ).mul( exp( float( - 0.5 ).mul( x ).mul( x ).div( sigma.mul( sigma ) ) ).div( sigma ) );\r\n\r\n\t\t} );\r\n\r\n\t\tconst separableBlur = Fn( ( [ kernelRadius ] ) => {\r\n\r\n\t\t\tconst resolution = textureSize( this._maskTextureDownsSampleUniform );\r\n\t\t\tconst invSize = vec2( 1 ).div( resolution ).toVar();\r\n\t\t\tconst uvNode = uv();\r\n\r\n\t\t\tconst sigma = kernelRadius.div( 2 ).toVar();\r\n\t\t\tconst weightSum = gaussianPdf( 0, sigma ).toVar();\r\n\t\t\tconst diffuseSum = this._blurColorTextureUniform.sample( uvNode ).mul( weightSum ).toVar();\r\n\t\t\tconst delta = this._blurDirection.mul( invSize ).mul( kernelRadius ).div( MAX_RADIUS ).toVar();\r\n\r\n\t\t\tconst uvOffset = delta.toVar();\r\n\r\n\t\t\tLoop( { start: int( 1 ), end: int( MAX_RADIUS ), type: 'int', condition: '<=' }, ( { i } ) => {\r\n\r\n\t\t\t\tconst x = kernelRadius.mul( float( i ) ).div( MAX_RADIUS );\r\n\t\t\t\tconst w = gaussianPdf( x, sigma );\r\n\t\t\t\tconst sample1 = this._blurColorTextureUniform.sample( uvNode.add( uvOffset ) );\r\n\t\t\t\tconst sample2 = this._blurColorTextureUniform.sample( uvNode.sub( uvOffset ) );\r\n\r\n\t\t\t\tdiffuseSum.addAssign( sample1.add( sample2 ).mul( w ) );\r\n\t\t\t\tweightSum.addAssign( w.mul( 2 ) );\r\n\t\t\t\tuvOffset.addAssign( delta );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn diffuseSum.div( weightSum );\r\n\r\n\t\t} );\r\n\r\n\t\tthis._separableBlurMaterial.fragmentNode = separableBlur( this.edgeThicknessNode );\r\n\t\tthis._separableBlurMaterial.needsUpdate = true;\r\n\r\n\t\tthis._separableBlurMaterial2.fragmentNode = separableBlur( MAX_RADIUS );\r\n\t\tthis._separableBlurMaterial2.needsUpdate = true;\r\n\r\n\t\t// composite material\r\n\r\n\t\tconst composite = Fn( () => {\r\n\r\n\t\t\tconst edgeValue1 = this._edge1TextureUniform;\r\n\t\t\tconst edgeValue2 = this._edge2TextureUniform;\r\n\t\t\tconst maskColor = this._maskTextureUniform;\r\n\r\n\t\t\tconst edgeValue = edgeValue1.add( edgeValue2.mul( this.edgeGlowNode ) );\r\n\r\n\t\t\treturn maskColor.r.mul( edgeValue );\r\n\r\n\t\t} );\r\n\r\n\t\tthis._compositeMaterial.fragmentNode = composite();\r\n\t\tthis._compositeMaterial.needsUpdate = true;\r\n\r\n\t\treturn this._textureNode;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Frees internal resources. This method should be called\r\n\t * when the effect is no longer required.\r\n\t */\r\n\tdispose() {\r\n\r\n\t\tthis.selectedObjects.length = 0;\r\n\r\n\t\tthis._renderTargetDepthBuffer.dispose();\r\n\t\tthis._renderTargetMaskBuffer.dispose();\r\n\t\tthis._renderTargetMaskDownSampleBuffer.dispose();\r\n\t\tthis._renderTargetEdgeBuffer1.dispose();\r\n\t\tthis._renderTargetEdgeBuffer2.dispose();\r\n\t\tthis._renderTargetBlurBuffer1.dispose();\r\n\t\tthis._renderTargetBlurBuffer2.dispose();\r\n\t\tthis._renderTargetComposite.dispose();\r\n\r\n\t\tthis._depthMaterial.dispose();\r\n\t\tthis._prepareMaskMaterial.dispose();\r\n\t\tthis._materialCopy.dispose();\r\n\t\tthis._edgeDetectionMaterial.dispose();\r\n\t\tthis._separableBlurMaterial.dispose();\r\n\t\tthis._separableBlurMaterial2.dispose();\r\n\t\tthis._compositeMaterial.dispose();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the selection cache based on the selected objects.\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_updateSelectionCache() {\r\n\r\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\r\n\r\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\r\n\t\t\tselectedObject.traverse( ( object ) => {\r\n\r\n\t\t\t\tif ( object.isMesh ) this._selectionCache.add( object );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default OutlineNode;\r\n\r\n/**\r\n * TSL function for creating an outline effect around selected objects.\r\n *\r\n * @tsl\r\n * @function\r\n * @param {Scene} scene - A reference to the scene.\r\n * @param {Camera} camera - The camera the scene is rendered with.\r\n * @param {Object} params - The configuration parameters.\r\n * @param {Array<Object3D>} params.selectedObjects - An array of selected objects.\r\n * @param {Node<float>} [params.edgeThickness=float(1)] - The thickness of the edges.\r\n * @param {Node<float>} [params.edgeGlow=float(0)] - Can be used for animated glow/pulse effects.\r\n * @param {number} [params.downSampleRatio=2] - The downsample ratio.\r\n * @returns {OutlineNode}\r\n */\r\nexport const outline = ( scene, camera, params ) => nodeObject( new OutlineNode( scene, camera, params ) );\r\n"],
  "mappings": "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",
  "names": []
}
