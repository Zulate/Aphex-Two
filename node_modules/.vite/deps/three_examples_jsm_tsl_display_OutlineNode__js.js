import {
  Fn,
  Loop,
  exp,
  float,
  int,
  min,
  mul,
  nodeObject,
  orthographicDepthToViewZ,
  passTexture,
  perspectiveDepthToViewZ,
  positionView,
  reference,
  screenUV,
  texture,
  textureSize,
  uniform,
  uv,
  vec2,
  vec3,
  vec4
} from "./chunk-2OU25RA4.js";
import {
  NodeMaterial,
  NodeUpdateType,
  QuadMesh,
  RendererUtils,
  TempNode
} from "./chunk-XZBEWT76.js";
import {
  DepthTexture,
  FloatType,
  RenderTarget,
  Vector2
} from "./chunk-Y7IX3D6Q.js";

// node_modules/three/examples/jsm/tsl/display/OutlineNode.js
var _quadMesh = new QuadMesh();
var _size = new Vector2();
var _BLUR_DIRECTION_X = new Vector2(1, 0);
var _BLUR_DIRECTION_Y = new Vector2(0, 1);
var _rendererState;
var OutlineNode = class extends TempNode {
  static get type() {
    return "OutlineNode";
  }
  /**
   * Constructs a new outline node.
   *
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - The camera the scene is rendered with.
   * @param {Object} params - The configuration parameters.
   * @param {Array<Object3D>} params.selectedObjects - An array of selected objects.
   * @param {Node<float>} [params.edgeThickness=float(1)] - The thickness of the edges.
   * @param {Node<float>} [params.edgeGlow=float(0)] - Can be used for an animated glow/pulse effects.
   * @param {number} [params.downSampleRatio=2] - The downsample ratio.
   */
  constructor(scene, camera, params = {}) {
    super("vec4");
    const {
      selectedObjects = [],
      edgeThickness = float(1),
      edgeGlow = float(0),
      downSampleRatio = 2
    } = params;
    this.scene = scene;
    this.camera = camera;
    this.selectedObjects = selectedObjects;
    this.edgeThicknessNode = nodeObject(edgeThickness);
    this.edgeGlowNode = nodeObject(edgeGlow);
    this.downSampleRatio = downSampleRatio;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this._renderTargetDepthBuffer = new RenderTarget();
    this._renderTargetDepthBuffer.depthTexture = new DepthTexture();
    this._renderTargetDepthBuffer.depthTexture.type = FloatType;
    this._renderTargetMaskBuffer = new RenderTarget();
    this._renderTargetMaskDownSampleBuffer = new RenderTarget(1, 1, { depthBuffer: false });
    this._renderTargetEdgeBuffer1 = new RenderTarget(1, 1, { depthBuffer: false });
    this._renderTargetEdgeBuffer2 = new RenderTarget(1, 1, { depthBuffer: false });
    this._renderTargetBlurBuffer1 = new RenderTarget(1, 1, { depthBuffer: false });
    this._renderTargetBlurBuffer2 = new RenderTarget(1, 1, { depthBuffer: false });
    this._renderTargetComposite = new RenderTarget(1, 1, { depthBuffer: false });
    this._cameraNear = reference("near", "float", camera);
    this._cameraFar = reference("far", "float", camera);
    this._blurDirection = uniform(new Vector2());
    this._depthTextureUniform = texture(this._renderTargetDepthBuffer.depthTexture);
    this._maskTextureUniform = texture(this._renderTargetMaskBuffer.texture);
    this._maskTextureDownsSampleUniform = texture(this._renderTargetMaskDownSampleBuffer.texture);
    this._edge1TextureUniform = texture(this._renderTargetEdgeBuffer1.texture);
    this._edge2TextureUniform = texture(this._renderTargetEdgeBuffer2.texture);
    this._blurColorTextureUniform = texture(this._renderTargetEdgeBuffer1.texture);
    this._visibleEdgeColor = vec3(1, 0, 0);
    this._hiddenEdgeColor = vec3(0, 1, 0);
    this._depthMaterial = new NodeMaterial();
    this._depthMaterial.fragmentNode = vec4(0, 0, 0, 1);
    this._depthMaterial.name = "OutlineNode.depth";
    this._prepareMaskMaterial = new NodeMaterial();
    this._prepareMaskMaterial.name = "OutlineNode.prepareMask";
    this._materialCopy = new NodeMaterial();
    this._materialCopy.name = "OutlineNode.copy";
    this._edgeDetectionMaterial = new NodeMaterial();
    this._edgeDetectionMaterial.name = "OutlineNode.edgeDetection";
    this._separableBlurMaterial = new NodeMaterial();
    this._separableBlurMaterial.name = "OutlineNode.separableBlur";
    this._separableBlurMaterial2 = new NodeMaterial();
    this._separableBlurMaterial2.name = "OutlineNode.separableBlur2";
    this._compositeMaterial = new NodeMaterial();
    this._compositeMaterial.name = "OutlineNode.composite";
    this._selectionCache = /* @__PURE__ */ new Set();
    this._textureNode = passTexture(this, this._renderTargetComposite.texture);
  }
  /**
   * A mask value that represents the visible edge.
   *
   * @return {Node<float>} The visible edge.
   */
  get visibleEdge() {
    return this.r;
  }
  /**
   * A mask value that represents the hidden edge.
   *
   * @return {Node<float>} The hidden edge.
   */
  get hiddenEdge() {
    return this.g;
  }
  /**
   * Returns the result of the effect as a texture node.
   *
   * @return {PassTextureNode} A texture node that represents the result of the effect.
   */
  getTextureNode() {
    return this._textureNode;
  }
  /**
   * Sets the size of the effect.
   *
   * @param {number} width - The width of the effect.
   * @param {number} height - The height of the effect.
   */
  setSize(width, height) {
    this._renderTargetDepthBuffer.setSize(width, height);
    this._renderTargetMaskBuffer.setSize(width, height);
    this._renderTargetComposite.setSize(width, height);
    let resx = Math.round(width / this.downSampleRatio);
    let resy = Math.round(height / this.downSampleRatio);
    this._renderTargetMaskDownSampleBuffer.setSize(resx, resy);
    this._renderTargetEdgeBuffer1.setSize(resx, resy);
    this._renderTargetBlurBuffer1.setSize(resx, resy);
    resx = Math.round(resx / 2);
    resy = Math.round(resy / 2);
    this._renderTargetEdgeBuffer2.setSize(resx, resy);
    this._renderTargetBlurBuffer2.setSize(resx, resy);
  }
  /**
   * This method is used to render the effect once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  updateBefore(frame) {
    const { renderer } = frame;
    const { camera, scene } = this;
    _rendererState = RendererUtils.resetRendererAndSceneState(renderer, scene, _rendererState);
    const size = renderer.getDrawingBufferSize(_size);
    this.setSize(size.width, size.height);
    renderer.setClearColor(16777215, 1);
    this._updateSelectionCache();
    scene.overrideMaterial = this._depthMaterial;
    renderer.setRenderTarget(this._renderTargetDepthBuffer);
    renderer.setRenderObjectFunction((object, ...params) => {
      if (this._selectionCache.has(object) === false) {
        renderer.renderObject(object, ...params);
      }
    });
    renderer.render(scene, camera);
    scene.overrideMaterial = this._prepareMaskMaterial;
    renderer.setRenderTarget(this._renderTargetMaskBuffer);
    renderer.setRenderObjectFunction((object, ...params) => {
      if (this._selectionCache.has(object) === true) {
        renderer.renderObject(object, ...params);
      }
    });
    renderer.render(scene, camera);
    renderer.setRenderObjectFunction(_rendererState.renderObjectFunction);
    this._selectionCache.clear();
    _quadMesh.material = this._materialCopy;
    renderer.setRenderTarget(this._renderTargetMaskDownSampleBuffer);
    _quadMesh.render(renderer);
    _quadMesh.material = this._edgeDetectionMaterial;
    renderer.setRenderTarget(this._renderTargetEdgeBuffer1);
    _quadMesh.render(renderer);
    this._blurColorTextureUniform.value = this._renderTargetEdgeBuffer1.texture;
    this._blurDirection.value.copy(_BLUR_DIRECTION_X);
    _quadMesh.material = this._separableBlurMaterial;
    renderer.setRenderTarget(this._renderTargetBlurBuffer1);
    _quadMesh.render(renderer);
    this._blurColorTextureUniform.value = this._renderTargetBlurBuffer1.texture;
    this._blurDirection.value.copy(_BLUR_DIRECTION_Y);
    renderer.setRenderTarget(this._renderTargetEdgeBuffer1);
    _quadMesh.render(renderer);
    this._blurColorTextureUniform.value = this._renderTargetEdgeBuffer1.texture;
    this._blurDirection.value.copy(_BLUR_DIRECTION_X);
    _quadMesh.material = this._separableBlurMaterial2;
    renderer.setRenderTarget(this._renderTargetBlurBuffer2);
    _quadMesh.render(renderer);
    this._blurColorTextureUniform.value = this._renderTargetBlurBuffer2.texture;
    this._blurDirection.value.copy(_BLUR_DIRECTION_Y);
    renderer.setRenderTarget(this._renderTargetEdgeBuffer2);
    _quadMesh.render(renderer);
    _quadMesh.material = this._compositeMaterial;
    renderer.setRenderTarget(this._renderTargetComposite);
    _quadMesh.render(renderer);
    RendererUtils.restoreRendererAndSceneState(renderer, scene, _rendererState);
  }
  /**
   * This method is used to setup the effect's TSL code.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {PassTextureNode}
   */
  setup() {
    const prepareMask = () => {
      const depth = this._depthTextureUniform.sample(screenUV);
      let viewZNode;
      if (this.camera.isPerspectiveCamera) {
        viewZNode = perspectiveDepthToViewZ(depth, this._cameraNear, this._cameraFar);
      } else {
        viewZNode = orthographicDepthToViewZ(depth, this._cameraNear, this._cameraFar);
      }
      const depthTest = positionView.z.lessThanEqual(viewZNode).select(1, 0);
      return vec4(0, depthTest, 1, 1);
    };
    this._prepareMaskMaterial.fragmentNode = prepareMask();
    this._prepareMaskMaterial.needsUpdate = true;
    this._materialCopy.fragmentNode = this._maskTextureUniform;
    this._materialCopy.needsUpdate = true;
    const edgeDetection = Fn(() => {
      const resolution = textureSize(this._maskTextureDownsSampleUniform);
      const invSize = vec2(1).div(resolution).toVar();
      const uvOffset = vec4(1, 0, 0, 1).mul(vec4(invSize, invSize));
      const uvNode = uv();
      const c1 = this._maskTextureDownsSampleUniform.sample(uvNode.add(uvOffset.xy)).toVar();
      const c2 = this._maskTextureDownsSampleUniform.sample(uvNode.sub(uvOffset.xy)).toVar();
      const c3 = this._maskTextureDownsSampleUniform.sample(uvNode.add(uvOffset.yw)).toVar();
      const c4 = this._maskTextureDownsSampleUniform.sample(uvNode.sub(uvOffset.yw)).toVar();
      const diff1 = mul(c1.r.sub(c2.r), 0.5);
      const diff2 = mul(c3.r.sub(c4.r), 0.5);
      const d = vec2(diff1, diff2).length();
      const a1 = min(c1.g, c2.g);
      const a2 = min(c3.g, c4.g);
      const visibilityFactor = min(a1, a2);
      const edgeColor = visibilityFactor.oneMinus().greaterThan(1e-3).select(this._visibleEdgeColor, this._hiddenEdgeColor);
      return vec4(edgeColor, 1).mul(d);
    });
    this._edgeDetectionMaterial.fragmentNode = edgeDetection();
    this._edgeDetectionMaterial.needsUpdate = true;
    const MAX_RADIUS = 4;
    const gaussianPdf = Fn(([x, sigma]) => {
      return float(0.39894).mul(exp(float(-0.5).mul(x).mul(x).div(sigma.mul(sigma))).div(sigma));
    });
    const separableBlur = Fn(([kernelRadius]) => {
      const resolution = textureSize(this._maskTextureDownsSampleUniform);
      const invSize = vec2(1).div(resolution).toVar();
      const uvNode = uv();
      const sigma = kernelRadius.div(2).toVar();
      const weightSum = gaussianPdf(0, sigma).toVar();
      const diffuseSum = this._blurColorTextureUniform.sample(uvNode).mul(weightSum).toVar();
      const delta = this._blurDirection.mul(invSize).mul(kernelRadius).div(MAX_RADIUS).toVar();
      const uvOffset = delta.toVar();
      Loop({ start: int(1), end: int(MAX_RADIUS), type: "int", condition: "<=" }, ({ i }) => {
        const x = kernelRadius.mul(float(i)).div(MAX_RADIUS);
        const w = gaussianPdf(x, sigma);
        const sample1 = this._blurColorTextureUniform.sample(uvNode.add(uvOffset));
        const sample2 = this._blurColorTextureUniform.sample(uvNode.sub(uvOffset));
        diffuseSum.addAssign(sample1.add(sample2).mul(w));
        weightSum.addAssign(w.mul(2));
        uvOffset.addAssign(delta);
      });
      return diffuseSum.div(weightSum);
    });
    this._separableBlurMaterial.fragmentNode = separableBlur(this.edgeThicknessNode);
    this._separableBlurMaterial.needsUpdate = true;
    this._separableBlurMaterial2.fragmentNode = separableBlur(MAX_RADIUS);
    this._separableBlurMaterial2.needsUpdate = true;
    const composite = Fn(() => {
      const edgeValue1 = this._edge1TextureUniform;
      const edgeValue2 = this._edge2TextureUniform;
      const maskColor = this._maskTextureUniform;
      const edgeValue = edgeValue1.add(edgeValue2.mul(this.edgeGlowNode));
      return maskColor.r.mul(edgeValue);
    });
    this._compositeMaterial.fragmentNode = composite();
    this._compositeMaterial.needsUpdate = true;
    return this._textureNode;
  }
  /**
   * Frees internal resources. This method should be called
   * when the effect is no longer required.
   */
  dispose() {
    this.selectedObjects.length = 0;
    this._renderTargetDepthBuffer.dispose();
    this._renderTargetMaskBuffer.dispose();
    this._renderTargetMaskDownSampleBuffer.dispose();
    this._renderTargetEdgeBuffer1.dispose();
    this._renderTargetEdgeBuffer2.dispose();
    this._renderTargetBlurBuffer1.dispose();
    this._renderTargetBlurBuffer2.dispose();
    this._renderTargetComposite.dispose();
    this._depthMaterial.dispose();
    this._prepareMaskMaterial.dispose();
    this._materialCopy.dispose();
    this._edgeDetectionMaterial.dispose();
    this._separableBlurMaterial.dispose();
    this._separableBlurMaterial2.dispose();
    this._compositeMaterial.dispose();
  }
  /**
   * Updates the selection cache based on the selected objects.
   *
   * @private
   */
  _updateSelectionCache() {
    for (let i = 0; i < this.selectedObjects.length; i++) {
      const selectedObject = this.selectedObjects[i];
      selectedObject.traverse((object) => {
        if (object.isMesh) this._selectionCache.add(object);
      });
    }
  }
};
var OutlineNode_default = OutlineNode;
var outline = (scene, camera, params) => nodeObject(new OutlineNode(scene, camera, params));
export {
  OutlineNode_default as default,
  outline
};
//# sourceMappingURL=three_examples_jsm_tsl_display_OutlineNode__js.js.map
